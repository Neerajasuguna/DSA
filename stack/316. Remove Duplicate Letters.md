Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.

 

Example 1:

Input: s = "bcabc"
Output: "abc"
Example 2:

Input: s = "cbacdcbc"
Output: "acdb"
 

Constraints:

1 <= s.length <= 104
s consists of lowercase English letters.


**Problem Restated**

        Each character must appear exactly once
        
        Result must be lexicographically smallest
        
        You cannot reorder arbitrarily â€” you must respect the original string order

**ðŸ”‘ Key Insight **

      If a bigger character appears before a smaller character,
      and the bigger character appears again later,
      then it is safe to remove the bigger character now.
      
      This is why we use:
      
      Monotonic increasing stack
      
      Last occurrence tracking
      
      Visited set



*âœ… Step-by-Step Algorithm

        Record last occurrence of every character
        
        Maintain:
        
        stack â†’ result characters
        
        seen[] â†’ whether character already used
        
        For each character:
        
        If already seen â†’ skip
        
        While:
        
        stack not empty
        
        top > current character
        
        top appears again later
        â†’ pop from stack
        
        Push current character
        
        Build result from stack

*Java Solution*

    class Solution {
    public String removeDuplicateLetters(String s) {
        int[] lastIndex = new int[26];
        boolean[] seen = new boolean[26];
        Deque<Character> stack = new ArrayDeque<>();

        // Step 1: record last occurrence
        for (int i = 0; i < s.length(); i++) {
            lastIndex[s.charAt(i) - 'a'] = i;
        }

        // Step 2: process characters
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            int idx = c - 'a';

            if (seen[idx]) continue;

            while (!stack.isEmpty()
                    && stack.peekLast() > c
                    && lastIndex[stack.peekLast() - 'a'] > i) {
                char removed = stack.pollLast();
                seen[removed - 'a'] = false;
            }

            stack.offerLast(c);
            seen[idx] = true;
        }

        // Step 3: build result
        StringBuilder sb = new StringBuilder();
        for (char c : stack) sb.append(c);

        return sb.toString();
    }
    }



TC- | Metric | Value                 |
| ------ | --------------------- |
| Time   | **O(n)**              |
| Space  | **O(1)** (26 letters) |



Similar Problem 

https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/


