Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].

Return true if there is a 132 pattern in nums, otherwise, return false.

 

Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
 

What makes it tricky is the order constraint: i < j < k and the value constraint:

nums[i] < nums[k] < nums[j]


Iâ€™ll explain the core idea, intuition, and then give you the final Java solution.

ğŸ§  Key Insight (This is the â€œahaâ€)

Instead of trying all triples (O(nÂ³)), we:

ğŸ‘‰ Fix nums[j] as the â€œ3â€
ğŸ‘‰ Try to find a â€œ2â€ (nums[k]) smaller than nums[j]
ğŸ‘‰ And check if there exists a â€œ1â€ (nums[i]) smaller than that â€œ2â€ before j

To do this efficiently, we scan from right to left.

ğŸ¯ Why Right â†’ Left?

Because:

When scanning from right,

All elements to the right of j are already seen

We can maintain candidates for the â€œ2â€ using a stack

ğŸ§© Strategy (Monotonic Stack)
Maintain:

A monotonic decreasing stack â†’ candidates for nums[j]

A variable third â†’ best candidate for nums[k] (the â€œ2â€)

ğŸ§  What does third represent?

third is the largest possible value that is smaller than some nums[j],
so it can act as nums[k].

If at any point:

nums[i] < third


ğŸ‘‰ We found a 132 pattern.

ğŸªœ Step-by-Step Algorithm

Initialize:

third = Integer.MIN_VALUE

Empty stack

Traverse array from right to left

If nums[i] < third â†’ âœ… return true

While stack not empty and nums[i] > stack.peek():

Pop from stack

Update third to popped value

Push nums[i] onto stack

If loop ends â†’ âŒ return false

ğŸ§ª Dry Run (Example 2)
Input
nums = [3, 1, 4, 2]


Traverse from right:

i	nums[i]	stack	third	action
3	2	[]	-âˆ	push 2
2	4	[2]	2	pop â†’ third=2, push 4
1	1	[4]	2	1 < 2 â†’ FOUND

âœ… Pattern: [1, 4, 2]





            class Solution {
                public boolean find132pattern(int[] nums) {
                    int third = Integer.MIN_VALUE;
                    Deque<Integer> stack = new ArrayDeque<>();
            
                    for (int i = nums.length - 1; i >= 0; i--) {
                        if (nums[i] < third) {
                            return true;
                        }
            
                        while (!stack.isEmpty() && nums[i] > stack.peek()) {
                            third = stack.pop();
                        }
            
                        stack.push(nums[i]);
                    }
            
                    return false;
                }
            }
