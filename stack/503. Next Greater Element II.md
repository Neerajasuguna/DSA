Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.

The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.

 

Example 1:

Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
Example 2:

Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]

**Aproach - â€œTo handle circularity, I conceptually duplicate the array by iterating from 2nâˆ’1 to 0 and use i % n to map indices. This ensures every element can see all elements after it in circular order.â€
**

We want Next Greater Element in a circular array.
ğŸ”´ Problem With Normal Traversal
Example
nums = [1, 2, 1]


If we do normal right-to-left traversal:

i = 2 â†’ 1 â†’ 0
values = 1 â†’ 2 â†’ 1


The first 1 (index 0) never sees the 2 at index 1 after wrap-around.
âŒ Wrong result.

ğŸŸ¢ Idea 1: â€œDuplicateâ€ the array (Mentally)

Instead of:

[1, 2, 1]


Think of it as:

[1, 2, 1, 1, 2, 1]


This allows every element to see elements to its right, even after wrap-around.

But we donâ€™t actually copy the array (wastes memory).

ğŸŸ¢ Idea 2: Simulate duplication using indices

If array length = n

We loop:

i = 2n - 1 â†’ 0


And access:

nums[i % n]

Why i % n?

Because:

When i >= n, i % n maps back to valid indices

This repeats the array logically

ğŸ§  Visual Mapping (Example)
nums = [1, 2, 1], n = 3

i     i % n     value
--------------------
5       2        1
4       1        2
3       0        1
2       2        1
1       1        2
0       0        1


This is exactly:

[1, 2, 1, 1, 2, 1]  (right to left)

ğŸŸ¢ Why Traverse From 2n - 1 to 0?
Interviewer Hint:

â€œFor next greater, every element needs to know what comes after it.â€

By traversing from the end of the duplicated array, the stack is already filled with:

All elements to the right

Including circular wrap-around elements

So when we reach original indices (i < n), we already know:

â€œWhatâ€™s the first greater element ahead of me?â€



     class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n= nums.length;
        int[] res=new int[n];
        Arrays.fill(res,-1);
        Deque<Integer>stack=new ArrayDeque<>();
        for(int i=2*n-1; i>=0;i--){
            int indx= i%n;
            while(!stack.isEmpty() && stack.peek()<=nums[indx]){
                stack.pop();
            }
            res[indx]=stack.isEmpty()?-1:stack.peek();
            stack.push(nums[indx]);

        }

        return res;
        
    }
    }

    TC- o(n)
     SC- O(n)
