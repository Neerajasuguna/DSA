We have n cities labeled from 1 to n. Two different cities with labels x and y are directly connected by a bidirectional road if and only if x and y share a common divisor strictly greater than some threshold. More formally, cities with labels x and y have a road between them if there exists an integer z such that all of the following are true:

x % z == 0,
y % z == 0, and
z > threshold.
Given the two integers, n and threshold, and an array of queries, you must determine for each queries[i] = [ai, bi] if cities ai and bi are connected directly or indirectly. (i.e. there is some path between them).

Return an array answer, where answer.length == queries.length and answer[i] is true if for the ith query, there is a path between ai and bi, or answer[i] is false if there is no path.

 

Example 1:


Input: n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
Output: [false,false,true]
Explanation: The divisors for each number:
1:   1
2:   1, 2
3:   1, 3
4:   1, 2, 4
5:   1, 5
6:   1, 2, 3, 6
Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the
only ones directly connected. The result of each query:
[1,4]   1 is not connected to 4
[2,5]   2 is not connected to 5
[3,6]   3 is connected to 6 through path 3--6
Example 2:


Input: n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
Output: [true,true,true,true,true]
Explanation: The divisors for each number are the same as the previous example. However, since the threshold is 0,
all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.
Example 3:


Input: n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
Output: [false,false,false,false,false]
Explanation: Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.
Please notice that there can be multiple queries for the same pair of nodes [x, y], and that the query [x, y] is equivalent to the query [y, x].
 

Constraints:

2 <= n <= 104
0 <= threshold <= n
1 <= queries.length <= 105
queries[i].length == 2
1 <= ai, bi <= cities
ai != bi






Key Observations

If z > threshold, then all multiples of z (i.e., z, 2z, 3z, ... ‚â§ n) are connected together because they all share the divisor z.

So, for each z from threshold + 1 to n, we can connect all its multiples.

Once we connect everything, we just need to check if two nodes belong to the same connected component ‚Äî perfect use case for Union-Find (Disjoint Set Union, DSU).

üí° Example Walkthrough
Example 1:
n = 6, threshold = 2
queries = [[1,4],[2,5],[3,6]]


We iterate z from 3 to 6:

z = 3: Connect all multiples of 3 ‚Üí (3, 6)

z = 4: multiples of 4 ‚Üí (4) ‚Üí only one, skip

z = 5: multiples of 5 ‚Üí (5) ‚Üí only one, skip

z = 6: multiples of 6 ‚Üí (6) ‚Üí only one, skip

Only connection = 3 ‚Üî 6.

‚úÖ Answer:

[1,4] -> false
[2,5] -> false
[3,6] -> true

üß† Algorithm

Initialize DSU for 1...n.

For every z from threshold + 1 to n:

For each multiple m = 2*z, 3*z, ... ‚â§ n:

Union z and m.

For each query [a, b]:

Check if find(a) == find(b).

‚è±Ô∏è Time Complexity

Building connections:

**O(nlogn)**

(Because for each z, we visit multiples up to n/z times)

Query processing:

**O(Q‚ãÖŒ±(n))**

where Œ±(n) is inverse Ackermann (almost constant)

**‚úÖ Total: O(n log n + Q) ‚Äî very efficient for given constraints.**

‚úÖ Clean Java Implementation
class Solution {
    public boolean[] areConnected(int n, int threshold, int[][] queries) {
        DSU dsu = new DSU(n + 1);
        
        for (int z = threshold + 1; z <= n; z++) {
            for (int multiple = 2 * z; multiple <= n; multiple += z) {
                dsu.union(z, multiple);
            }
        }
        
        boolean[] ans = new boolean[queries.length];
        for (int i = 0; i < queries.length; i++) {
            int a = queries[i][0], b = queries[i][1];
            ans[i] = (dsu.find(a) == dsu.find(b));
        }
        
        return ans;
    }
}

class DSU {
    int[] parent, rank;
    
    DSU(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    
    int find(int x) {
        if (x != parent[x]) parent[x] = find(parent[x]);
        return parent[x];
    }
    
    void union(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return;
        if (rank[px] < rank[py]) parent[px] = py;
        else if (rank[py] < rank[px]) parent[py] = px;
        else {
            parent[py] = px;
            rank[px]++;
        }
    }
}

Space OCmplexity 
O(n+Q)

