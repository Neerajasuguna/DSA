Given an integer n and an array of distinct prime numbers primes, return the n-th super ugly number. A super ugly number is a positive integer whose only prime factors are from a given array primes.

The n-th super ugly number is guaranteed to fit within a 32-bit signed integer.




Algorithm 


## 🧠 Algorithm Explanation: Finding the n-th Super Ugly Number

A **super ugly number** is a positive integer whose **only prime factors** are from a given list of primes.

We aim to find the **n-th super ugly number** in ascending order using a **min-heap** for efficiency.

---

### ✅ Steps of the Algorithm:

1. **Initialize the Result List:**
   - Create a list `ugly` and initialize it with `1` (the first super ugly number).

2. **Initialize a Min-Heap:**
   - Use a **min-heap** (priority queue) to store the next candidates.
   - For each prime `p` in the input list, insert a tuple into the heap:
     ```
     (p, p, 0)
     ```
     - `p` is the first multiple of the prime.
     - The second `p` is the prime itself.
     - `0` is the index in the `ugly` list where the prime was last multiplied.

3. **Build the Super Ugly List:**
   - Repeat until we have `n` super ugly numbers in the list:
     - Extract the smallest element from the heap: `(nextUgly, prime, index)`.
     - If `nextUgly` is **not a duplicate** of the last value in `ugly`, add it to the list.
     - Compute the next candidate multiple using:
       ```
       newVal = prime * ugly[index + 1]
       ```
     - Push `(newVal, prime, index + 1)` back into the heap.

4. **Return the Result:**
   - Once the loop ends, the `n`-th super ugly number is the last element in the `ugly` list.

---

### 🕒 Time Complexity:
- **O(n log k)** where:
  - `n` is the number of super ugly numbers to find,
  - `k` is the number of primes.
- At each iteration, we push/pop from a heap of size `k`.

### 💾 Space Complexity:
- **O(n + k)**:
  - `n` space for the `ugly` list,
  - `k` space for the heap storing candidates.








solution 

import java.util.*;

public class SuperUglyNumber {
    
    public static int nthSuperUglyNumber(int n, int[] primes) {
        List<Integer> ugly = new ArrayList<>();
        ugly.add(1);
        
        // Min-heap storing: [nextUgly, prime, index]
        PriorityQueue<long[]> minHeap = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));
        
        for (int prime : primes) {
            minHeap.offer(new long[]{prime, prime, 0});
        }
        
        while (ugly.size() < n) {
            long[] entry = minHeap.poll();
            long nextUgly = entry[0];
            long prime = entry[1];
            int index = (int) entry[2];
            
            if (nextUgly != ugly.get(ugly.size() - 1)) {
                ugly.add((int) nextUgly);
            }
            
            long newVal = prime * ugly.get(index + 1);
            minHeap.offer(new long[]{newVal, prime, index + 1});
        }
        
        return ugly.get(n - 1);
    }

    public static void main(String[] args) {
        int[] nValues = {12, 1, 15, 10, 8};
        int[][] primesList = {
            {2, 7, 13, 19},
            {2, 3, 5},
            {3, 5, 7},
            {2, 5, 11},
            {3, 11, 17}
        };

        for (int i = 0; i < nValues.length; i++) {
            int n = nValues[i];
            int[] primes = primesList[i];
            
            System.out.println((i + 1) + ".\tn: " + n);
            System.out.print("\tprimes: " + Arrays.toString(primes));
            System.out.println();

            int result = nthSuperUglyNumber(n, primes);
            System.out.println("\n\t" + n + "th super ugly number is " + result);
            System.out.println("-".repeat(100));
        }
    }
}




similar but simple approach

We need to generate numbers whose prime factors come only from a given set of primes.


Key Observation

If a number x is a super ugly number,
then any multiple of it by a valid prime p (x * p)
is also a super ugly number.

✅ So from 1, we can generate:
1 * 2 = 2, 1 * 7 = 7, 1 * 13 = 13, 1 * 19 = 19.

Then from 2, we can generate:
2*2 = 4, 2*7 = 14, 2*13 = 26, 2*19 = 38.

and so on…

So if we keep multiplying previously found numbers by primes,
we can generate all super ugly numbers.

⸻

⚙️ The Challenge

If we just generate all possible combinations and sort them,
we’ll have huge duplicates and massive sorting cost.
For example,
14 can come from 2*7 and 7*2.

We need a way to always pick the next smallest unique number efficiently — without sorting everything.

⸻

💡 The Heap Intuition

That’s where the min-heap idea shines 🌟

You can think of it like this:
	1.	We already know the smallest super ugly number: 1.
So start with heap = [1].
	2.	The next super ugly number must be one of:
1 * primes[i] = {2, 7, 13, 19} → put them in the heap.
	3.	Pop the smallest from heap → 2.
Then generate new candidates by multiplying 2 with all primes:
2×2=4, 2×7=14, 2×13=26, 2×19=38.
	4.	Each time we pop from the heap,
we are certain it is the next super ugly number —
because all future numbers are multiples of already smaller ones (hence, larger).







import java.util.*;

public class SuperUglyNumberHeap {
    public static int nthSuperUglyNumber(int n, int[] primes) {
        PriorityQueue<Long> pq = new PriorityQueue<>();
        Set<Long> seen = new HashSet<>();
        pq.add(1L);
        seen.add(1L);

        long ugly = 1;
        for (int i = 0; i < n; i++) {
            ugly = pq.poll();
            for (int p : primes) {
                long next = ugly * p;
                if (seen.add(next)) pq.add(next);
            }
        }
        return (int) ugly;
    }

    public static void main(String[] args) {
        int[] primes = {2, 7, 13, 19};
        int n = 12;
        System.out.println(nthSuperUglyNumber(n, primes)); // Output: 32
    }
}
