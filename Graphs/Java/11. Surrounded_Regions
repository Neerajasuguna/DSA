
You are given a matrix mat of size N x M where each cell contains either 'O' or 'X'.

Your task is to replace all 'O' cells that are completely surrounded by 'X' with 'X'.



Rules:

An 'O' (or a group of connected 'O's) is considered surrounded if it is not connected to any border of the matrix.
Two 'O' cells are considered connected if they are adjacent horizontally or vertically (not diagonally).
A region of connected 'O's that touches the border (i.e., first row, last row, first column, or last column) is not surrounded and should not be changed.





Approach 
âœ… BFS Approach (Three Steps):
1. Mark All Border-Connected 'O's:
  Traverse all 4 borders (first row, last row, first column, last column).
  For any 'O' found on the border, start a BFS to find all 'O's connected to it (i.e., the safe region).
  Mark all these safe 'O's as visited using a vis[][] array or any marker.

2. BFS Traversal:
  Use a queue to do level-order BFS.
  For each popped 'O', explore all 4 directions.
  If a neighboring cell is also an 'O' and unvisited, mark it visited and add it to the queue.

3. Flip All Unvisited 'O's to 'X':
  After the BFS is done, the vis[][] array tells you which 'O's are safe (connected to border).
  Traverse the board again:
  If a cell is 'O' and not visited â†’ itâ€™s a surrounded region â†’ flip it to 'X'.

ðŸ§  Why This Works:
We only preserve the 'O' cells that are connected to the border (because they can't be surrounded by definition).

All other 'O's must be inside closed boundaries of 'X' â€” so we can safely flip them.

ðŸ“¦ Space & Time Complexity:
Time: O(n * m) â†’ You scan every cell max once.

Space: O(n * m) for vis[][] + O(n * m) worst-case queue size.





import java.util.*;

public class SurroundedRegions {

    public void solve(char[][] board) {
        int n = board.length;
        int m = board[0].length;

        Queue<int[]> q = new LinkedList<>();
        int[][] vis = new int[n][m];

        // Step 1: Push all boundary 'O's into queue
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {
                    if (board[i][j] == 'O') {
                        q.add(new int[]{i, j});
                        vis[i][j] = 1;
                    }
                }
            }
        }

        // Step 2: BFS from border 'O's
        int[] drow = {-1, 0, 1, 0};
        int[] dcol = {0, 1, 0, -1};

        while (!q.isEmpty()) {
            int[] cell = q.poll();
            int i = cell[0];
            int j = cell[1];

            for (int k = 0; k < 4; k++) {
                int nrow = i + drow[k];
                int ncol = j + dcol[k];

                if (nrow > 0 && nrow < n && ncol > 0 && ncol < m &&
                    board[nrow][ncol] == 'O' && vis[nrow][ncol] == 0) {
                    vis[nrow][ncol] = 1;
                    q.add(new int[]{nrow, ncol});
                }
            }
        }

        // Step 3: Convert unvisited 'O' to 'X'
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (vis[i][j] == 0 && board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }




Without viisted BFS 

Intuition

The 'O's on the border (first/last row/column) cannot ever be surrounded.

Any 'O' connected to those border 'O's is also safe (cannot be surrounded).

All other 'O's are truly surrounded â€” change them to 'X'.

So we:

Step 1ï¸âƒ£ â†’ Find all 'O's on the border.

Step 2ï¸âƒ£ â†’ Use DFS/BFS to mark all 'O's connected to these as safe.

Step 3ï¸âƒ£ â†’ Convert all unmarked 'O' â†’ 'X'.

Step 4ï¸âƒ£ â†’ Restore all marked (safe) 'O's back to 'O'.
import java.util.*;

class Solution {
    public void replaceSurrounded(char[][] mat) {
        int n = mat.length;
        int m = mat[0].length;

        Queue<int[]> q = new LinkedList<>();
        
        // Step 1: Add all border 'O's to queue
        for (int i = 0; i < n; i++) {
            if (mat[i][0] == 'O') q.offer(new int[]{i, 0});
            if (mat[i][m - 1] == 'O') q.offer(new int[]{i, m - 1});
        }
        for (int j = 0; j < m; j++) {
            if (mat[0][j] == 'O') q.offer(new int[]{0, j});
            if (mat[n - 1][j] == 'O') q.offer(new int[]{n - 1, j});
        }

        // Step 2: BFS to mark all connected 'O's as safe
        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int r = cur[0], c = cur[1];
            if (r < 0 || c < 0 || r >= n || c >= m || mat[r][c] != 'O') continue;
            mat[r][c] = '#'; // mark safe temporarily

            for (int[] d : dirs) {
                int nr = r + d[0], nc = c + d[1];
                if (nr >= 0 && nc >= 0 && nr < n && nc < m && mat[nr][nc] == 'O') {
                    q.offer(new int[]{nr, nc});
                }
            }
        }

        // Step 3: Replace all remaining 'O' â†’ 'X', and '#' â†’ 'O'
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == 'O') mat[i][j] = 'X';
                else if (mat[i][j] == '#') mat[i][j] = 'O';
            }
        }
    }
}





DFS 

class Solution {
    public void replaceSurrounded(char[][] mat) {
        int n = mat.length, m = mat[0].length;

        // Step 1: DFS from borders
        for (int i = 0; i < n; i++) {
            dfs(mat, i, 0);
            dfs(mat, i, m - 1);
        }
        for (int j = 0; j < m; j++) {
            dfs(mat, 0, j);
            dfs(mat, n - 1, j);
        }

        // Step 2: Convert surrounded 'O' â†’ 'X', and '#' â†’ 'O'
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == 'O') mat[i][j] = 'X';
                else if (mat[i][j] == '#') mat[i][j] = 'O';
            }
        }
    }

    private void dfs(char[][] mat, int i, int j) {
        int n = mat.length, m = mat[0].length;
        if (i < 0 || j < 0 || i >= n || j >= m || mat[i][j] != 'O') return;
        mat[i][j] = '#'; // mark as safe
        dfs(mat, i + 1, j);
        dfs(mat, i - 1, j);
        dfs(mat, i, j + 1);
        dfs(mat, i, j - 1);
    }
}





