Detect a cycle in undirect graph 


Intuition:
While performing DFS in an undirected graph, if you visit a neighbor that is already visited and it's not the parent, then you've found a cycle.

🔁 Step-by-Step:
Use a visited[] array to keep track of which nodes are visited.
For every unvisited node, call a recursive DFS function.
In DFS:
Mark the current node as visited.
For each neighbor of the current node:
If not visited:
Recursively call DFS on it with the current node as the parent.
If already visited and neighbor ≠ parent, then it's a back edge, so a cycle exists.

🧠 Why we track the parent?
Because in undirected graphs, you can return to the immediate node you came from (the parent). That’s not a cycle. A cycle exists only when you go back to an already visited node that is not the parent.

🔍 Example:
For this graph:

yaml
Copy
Edit
0 — 1
 \  |
   2
DFS from 0:

0 → 1 → 2

From 2, you see 0 again. Since 0 is not 2’s parent, it's a cycle.





public static boolean hasCycle(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];

        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                if (dfs(i, -1, visited, adj)) {
                    return true;
                }
            }
        }

        return false;
    }

    private static boolean dfs(int node, int parent, boolean[] visited, List<List<Integer>> adj) {
        visited[node] = true;

        for (int neighbor : adj.get(node)) {
            if (!visited[neighbor]) {
                if (dfs(neighbor, node, visited, adj)) {
                    return true;
                }
            } else if (neighbor != parent) {
                // Visited neighbor that's not the parent ⇒ cycle
                return true;
            }
        }

        return false;
    }
}
