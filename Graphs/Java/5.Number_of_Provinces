

Given an undirected graph with V vertices. Two vertices u and v belong to a single province if there is a path from u to v or v to u.
Find the number of provinces. The graph is given as an n x n matrix adj where adj[i][j] = 1 if the ith city and the jth city are directly connected, and adj[i][j] = 0 otherwise.
A province is a group of directly or indirectly connected cities and no other cities outside of the group.



DFS Solution 


public class NumberOfProvinces {

    public static int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] visited = new boolean[n];
        int count = 0;

        // Loop through each city
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(isConnected, visited, i);
                count++; // one complete component = one province
            }
        }

        return count;
    }

    // Standard DFS on matrix
    private static void dfs(int[][] adj, boolean[] visited, int node) {
        visited[node] = true;
        for (int j = 0; j < adj.length; j++) {
            if (adj[node][j] == 1 && !visited[j]) {
                dfs(adj, visited, j);
            }
        }
    }

    public static void main(String[] args) {
        int[][] adj = {
            {1, 0, 0, 1},
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {1, 0, 0, 1}
        };

        int result = findCircleNum(adj);
        System.out.println("Number of provinces: " + result); // Output: 2
    }
}





BFS Solution 


import java.util.*;

public class NumberOfProvincesBFS {

    public static int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] visited = new boolean[n];
        int count = 0;

        // Loop through each city
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                bfs(isConnected, visited, i);
                count++; // One connected component found
            }
        }

        return count;
    }

    private static void bfs(int[][] adj, boolean[] visited, int start) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        visited[start] = true;

        while (!queue.isEmpty()) {
            int node = queue.poll();
            for (int j = 0; j < adj.length; j++) {
                if (adj[node][j] == 1 && !visited[j]) {
                    queue.offer(j);
                    visited[j] = true;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[][] adj = {
            {1, 0, 0, 1},
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {1, 0, 0, 1}
        };

        int result = findCircleNum(adj);
        System.out.println("Number of provinces: " + result); // Output: 2
    }
}
Time complexity is O(v*v)
Space - O(v) ---- for visited



Approach 3 â€” Union Find (Disjoint Set Union)

This is the most elegant when you want high performance.

Idea:

Initially, every city is its own province.

For every connection isConnected[i][j] == 1,
union the two cities.

At the end, count the number of unique parents (roots).

Java Code â€” Union Find
class DSU {
    int[] parent;

    DSU(int n) {
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]); // path compression
        return parent[x];
    }

    void union(int a, int b) {
        int pa = find(a), pb = find(b);
        if (pa != pb)
            parent[pa] = pb;
    }
}

public class NumberOfProvincesUF {
    public static int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        DSU dsu = new DSU(n);

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1)
                    dsu.union(i, j);
            }
        }

        Set<Integer> provinces = new HashSet<>();
        for (int i = 0; i < n; i++)
            provinces.add(dsu.find(i));

        return provinces.size();
    }

    public static void main(String[] args) {
        int[][] isConnected = {
            {1, 1, 0},
            {1, 1, 0},
            {0, 0, 1}
        };
        System.out.println("Number of Provinces: " + findCircleNum(isConnected)); // Output: 2
    }
}



Time COmplexity 


Union and Find Operations

Each union() and find() operation has a very low time cost due to two optimizations:

Path Compression: Flattens the tree structure
(makes future finds nearly O(1))

Union by Rank / Size: Keeps the tree shallow

Because of these optimizations,
both operations run in amortized O(Î±(N)) time,
where Î±(N) = inverse Ackermann function.

ðŸ‘‰ For all practical purposes, Î±(N) â‰¤ 4 even for very large N (like 10â¹).

So, itâ€™s effectively constant time.

At the end, we loop once through all nodes to count unique parents:

O(N)


************The DSU approach is asymptotically O(NÂ²),
but faster in practice than DFS/BFS because
unionâ€“find operations are almost constant time.************
