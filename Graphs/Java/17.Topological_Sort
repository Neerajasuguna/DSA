DFS Approach - we use stack to store nodes 

Approach Explanation
DFS Traversal: For each unvisited node, do a DFS traversal.

Post-Visit Push: Once all its children are visited, push the current node onto a stack.

Stack Order: The topological order is the reverse of finishing times, hence popping from the stack gives the required order.

Visited Array: Keeps track of nodes already visited.



private void dfs(int node, boolean[] visited, Stack<Integer> stack, List<List<Integer>> adj) {
        visited[node] = true;

        for (int neighbor : adj.get(node)) {
            if (!visited[neighbor]) {
                dfs(neighbor, visited, stack, adj);
            }
        }

        stack.push(node); // Add to stack after visiting all neighbors
    }

    // Function to return list containing vertices in Topological order
    public List<Integer> topoSort(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, visited, stack, adj);
            }
        }

        List<Integer> topoOrder = new ArrayList<>();
        while (!stack.isEmpty()) {
            topoOrder.add(stack.pop());
        }

        return topoOrder;
    }



BFS Khan based Approach 


import java.util.*;

class Solution {
    // Function to return list containing vertices in Topological order.
    public List<Integer> topoSort(int V, List<List<Integer>> adj) {
        int[] indegree = new int[V];

        // Calculate indegree of each node
        for (int i = 0; i < V; i++) {
            for (int neighbor : adj.get(i)) {
                indegree[neighbor]++;
            }
        }

        Queue<Integer> queue = new LinkedList<>();

        // Add all nodes with 0 indegree to the queue
        for (int i = 0; i < V; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }

        List<Integer> topoOrder = new ArrayList<>();

        while (!queue.isEmpty()) {
            int node = queue.poll();
            topoOrder.add(node);

            // Decrease indegree of all its neighbors
            for (int neighbor : adj.get(node)) {
                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }

        // If topoOrder size < V, there's a cycle in the graph
        if (topoOrder.size() != V) {
            throw new RuntimeException("Graph contains a cycle. Topological sort not possible.");
        }

        return topoOrder;
    }

    public static void main(String[] args) {
        int V = 6;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }

        // Directed edges
        adj.get(5).add(2);
        adj.get(5).add(0);
        adj.get(4).add(0);
        adj.get(4).add(1);
        adj.get(2).add(3);
        adj.get(3).add(1);

        Solution sol = new Solution();
        List<Integer> result = sol.topoSort(V, adj);

        System.out.println("Topological Sort (Kahn's Algorithm): " + result);
    }
}

Kahn’s Algorithm (BFS) – Explanation
Indegree Calculation: Count how many edges point into each node (indegree).

Queue Initialization: Start with nodes that have indegree = 0.

Processing:

Pop a node from the queue.

Add it to the topological sort.

Decrease the indegree of its neighbors.

If a neighbor’s indegree becomes 0, enqueue it.

Cycle Check: If not all nodes are processed, the graph contains a cycle.

