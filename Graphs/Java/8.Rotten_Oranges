Given an n x m grid, where each cell has the following values : 

2 - represents a rotten orange

1 - represents a Fresh orange

0 - represents an Empty Cell

Every minute, if a fresh orange is adjacent to a rotten orange in 4-direction ( upward, downwards, right, and left ) it becomes rotten. 

Return the minimum number of minutes required such that none of the cells has a Fresh Orange. If it's not possible, return -1.



import java.util.*;

class Solution {
    public int orangesRotting(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;

        Queue<int[]> queue = new LinkedList<>();
        int freshCount = 0;

        // Step 1: Count fresh oranges and add rotten ones to the queue
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                if (grid[r][c] == 2) {
                    queue.offer(new int[]{r, c});
                } else if (grid[r][c] == 1) {
                    freshCount++;
                }
            }
        }

        if (freshCount == 0) return 0; // No fresh oranges

        int minutes = 0;
        int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}}; // up, down, left, right

        // Step 2: BFS from all initially rotten oranges
        while (!queue.isEmpty()) {
            int size = queue.size();
            boolean rottedThisMinute = false;

            for (int i = 0; i < size; i++) {
                int[] cell = queue.poll();
                int r = cell[0];
                int c = cell[1];

                for (int[] dir : directions) {
                    int nr = r + dir[0];
                    int nc = c + dir[1];

                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1) {
                        grid[nr][nc] = 2;
                        freshCount--;
                        queue.offer(new int[]{nr, nc});
                        rottedThisMinute = true;
                    }
                }
            }

            if (rottedThisMinute) minutes++;
        }

        return freshCount == 0 ? minutes : -1;
    }
}


✅ Explanation (Approach)
Initial Scan: Count all fresh oranges and collect the positions of rotten oranges in a queue.
BFS Level Order:
For every minute (level of BFS), go through all rotten oranges.
For each rotten orange, rot the adjacent fresh oranges (up, down, left, right).
Add the newly rotten oranges to the queue.
Count Minutes: Each level of BFS represents one minute.
Final Check:
If all fresh oranges are rotten → return minutes.
If some fresh oranges remain → return -1.



| Metric           | Value            |
| ---------------- | ---------------- |
| Time Complexity  | O(m × n)         |
| Space Complexity | O(m × n) (queue) |






Time based approach 


import java.util.*;

class Solution {
    public int orangesRotting(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        Queue<int[]> q = new LinkedList<>();
        int fresh = 0;

        // Step 1: Add all rotten to queue, count fresh
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == 2)
                    q.offer(new int[]{i, j, 0});
                else if(grid[i][j] == 1)
                    fresh++;
            }
        }

        int time = 0;
        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};

        // Step 2: BFS Spread
        while(!q.isEmpty()){
            int[] cur = q.poll();
            int r = cur[0], c = cur[1], t = cur[2];
            time = Math.max(time, t);

            for(int[] d : dirs){
                int nr = r + d[0], nc = c + d[1];
                if(nr >= 0 && nc >= 0 && nr < m && nc < n && grid[nr][nc] == 1){
                    grid[nr][nc] = 2;  // rot it
                    fresh--;
                    q.offer(new int[]{nr, nc, t + 1});
                }
            }
        }

        return (fresh == 0) ? time : -1;
    }
}




There are two common BFS styles:

Level-based BFS (using for loop on queue size)

Timestamp-based BFS (store time inside queue)



What We Are Using in the Given Code

We pushed each rotten orange as:

q.offer(new int[]{r, c, time});


So we already store the time in the queue entry.

int[] cur = q.poll();
int t = cur[2];  // current time


Here time itself ensures level/layer order.

So even though we have:

while(!q.isEmpty())


we are still processing levels, because time increments only when a new layer is discovered.

If we did not store time, then yes — we would use Level BFS

Like this:

while(!q.isEmpty()) {
    int size = q.size(); // number of rotten oranges at this minute
    for(int i = 0; i < size; i++) {
        int[] cur = q.poll();
        // rot adjacent...
    }
    time++; // after finishing one full layer
}


This is the alternative valid approach.

Why Time-in-Queue Approach Works Without the For Loop

Because queue order guarantees:

All initially rotten oranges go in first with time = 0

All oranges infected by them go in with time = 1

All oranges infected next go in with time = 2
…and so on.

So BFS already processes them like layers.

You don’t need to manually control layers with for.





Final Summary

Because we stored the time inside the queue, BFS automatically handles multiple starting points and levels.
So we do NOT need an explicit for(queue.size()).
If we weren’t storing time, then yes, we would use the for-loop BFS.
